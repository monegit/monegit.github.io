{"version":3,"file":"component---src-pages-gallery-tus-voluteer-src-components-home-faq-tsx-919c72ee7d32d392fc1a.js","mappings":"oJAQA,MAAMA,EAAWC,IAAgD,MAC/D,MAAM,EAACC,EAAM,EAAEC,IAAaC,EAAAA,EAAAA,WAAS,GAC/BC,GAAmBC,EAAAA,EAAAA,KACnBC,GAAiBD,EAAAA,EAAAA,KAEvB,OACEE,EAAAA,cAACC,EAAAA,EAAAA,IAAU,CACTC,QAASH,EACTI,UAAU,8FACVC,QAAS,CACPC,WAAY,qBACZC,MAAO,IACPC,OAAQ,IAEVC,WAAY,CAAEH,WAAY,qBAAsBI,MAAO,MACvDC,MAAO,KACLf,GAAWD,GAEXK,EAAeY,MAAM,CACnBJ,OAAQb,EAAS,GAAK,OACtBkB,WAAY,CAAEC,KAAM,UAAWC,SAAU,MAE3CjB,EAAiBc,MAAM,CACrBI,QAASrB,EAAS,EAAI,EACtBkB,WAAY,CACVE,SAAU,KAEZ,GAGJd,EAAAA,cAAAA,MAAAA,CAAKG,UAAU,4BAA2B,MAAIV,EAAMuB,OACpDhB,EAAAA,cAACC,EAAAA,EAAAA,IAAU,CACTC,QAASL,EACTO,QAAS,CAAEW,QAAS,GACpBZ,UAAU,iBAEVH,EAAAA,cAAAA,MAAAA,CAAKG,UAAU,iCACC,QAD8B,EAC3CV,EAAMwB,eAAO,aAAbC,EAAeC,KAAKF,GACnBjB,EAAAA,cAAAA,MAAAA,CAAKG,UAAU,gBAAgBc,OAI1B,EAUjB,UAJA,SAAaxB,GACX,OAAOO,EAAAA,cAACR,EAAO,CAACwB,MAAOvB,EAAMuB,MAAOC,QAASxB,EAAMwB,SACrD,C,gHCnDA,SAASG,IAIL,IAAIC,GAAa,EAKjB,MAAMC,EAAoB,GAIpBC,EAAc,IAAIC,IAClBC,EAAW,CACbC,UAAUC,GAEN,OADAJ,EAAYK,IAAID,GACT,KAAWJ,EAAYM,OAAOF,EAAc,CACvD,EACAhB,MAAMmB,EAAYC,GAOd,GAAIV,EAAY,CACZ,MAAMW,EAAa,GAMnB,OALAT,EAAYU,SAASN,IACjBK,EAAWE,MAAK,QAAqBP,EAAeG,EAAY,CAC5DC,uBACD,IAEAI,QAAQC,IAAIJ,EACvB,CAEI,OAAO,IAAIG,SAASE,IAChBf,EAAkBY,KAAK,CACnBI,UAAW,CAACR,EAAYC,GACxBM,WACF,GAGd,EACAE,IAAIT,GAEA,OADA,OAAUT,EAAY,iHACfE,EAAYU,SAASN,KACxB,QAAUA,EAAeG,EAAW,GAE5C,EACAU,OACIjB,EAAYU,SAASN,KACjB,QAAcA,EAAc,GAEpC,EACAc,QAKI,OAJApB,GAAa,EACbC,EAAkBW,SAAQ,EAAGK,YAAWD,cACpCZ,EAASd,SAAS2B,GAAWI,KAAKL,EAAQ,IAEvC,KACHhB,GAAa,EACbI,EAASe,MAAM,CAEvB,GAEJ,OAAOf,CACX,C,wBCzCA,SAAS3B,IACL,MAAM2B,GAAW,OAAYL,GAE7B,OADA,IAAAuB,WAAUlB,EAASgB,MAAO,IACnBhB,CACX,CACA,MAAMmB,EAAe9C,C","sources":["webpack://portfolio/./src/pages/gallery/TUS-Voluteer/src/components/Home/FAQ.tsx","webpack://portfolio/./node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs","webpack://portfolio/./node_modules/framer-motion/dist/es/animation/hooks/use-animation.mjs"],"sourcesContent":["import React, { useState } from \"react\";\nimport { motion, useAnimationControls } from \"framer-motion\";\n\ninterface FAQData {\n  title: string;\n  content: string[];\n}\n\nconst FAQItem = (props: { title: string; content: string[] }) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const contentAnimation = useAnimationControls();\n  const panelAnimation = useAnimationControls();\n\n  return (\n    <motion.div\n      animate={panelAnimation}\n      className=\"flex flex-col gap-3 px-6 rounded-xl cursor-pointer select-none text-justify overflow-hidden\"\n      initial={{\n        background: \"rgb(226, 232, 240)\",\n        width: 900,\n        height: 60,\n      }}\n      whileHover={{ background: \"rgb(203, 213, 225)\", scale: 1.02 }}\n      onTap={() => {\n        setIsOpen(!isOpen);\n\n        panelAnimation.start({\n          height: isOpen ? 60 : \"auto\",\n          transition: { ease: \"circOut\", duration: 0.2 },\n        });\n        contentAnimation.start({\n          opacity: isOpen ? 0 : 1,\n          transition: {\n            duration: 0.2,\n          },\n        });\n      }}\n    >\n      <div className=\"font-medium text-lg mt-4\">Q. {props.title}</div>\n      <motion.div\n        animate={contentAnimation}\n        initial={{ opacity: 0 }}\n        className=\"flex relative\"\n      >\n        <div className=\"flex mb-4 flex-col gap-2 px-8\">\n          {props.content?.map((content) => (\n            <div className=\"flex text-sm\">{content}</div>\n          ))}\n        </div>\n      </motion.div>\n    </motion.div>\n  );\n};\n\nconst FAQPanel = () => {};\n\nfunction FAQ(props: FAQData) {\n  return <FAQItem title={props.title} content={props.content} />;\n}\n\nexport default FAQ;\n","import { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../../render/utils/animation.mjs';\nimport { setValues } from '../../render/utils/setters.mjs';\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    const pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                const animations = [];\n                subscribers.forEach((visualElement) => {\n                    animations.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride,\n                    }));\n                });\n                return Promise.all(animations);\n            }\n            else {\n                return new Promise((resolve) => {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve,\n                    });\n                });\n            }\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            pendingAnimations.forEach(({ animation, resolve }) => {\n                controls.start(...animation).then(resolve);\n            });\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls };\n","import { animationControls } from './animation-controls.mjs';\nimport { useEffect } from 'react';\nimport { useConstant } from '../../utils/use-constant.mjs';\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimationControls() {\n    const controls = useConstant(animationControls);\n    useEffect(controls.mount, []);\n    return controls;\n}\nconst useAnimation = useAnimationControls;\n\nexport { useAnimation, useAnimationControls };\n"],"names":["FAQItem","props","isOpen","setIsOpen","useState","contentAnimation","useAnimationControls","panelAnimation","React","motion","animate","className","initial","background","width","height","whileHover","scale","onTap","start","transition","ease","duration","opacity","title","content","_props$content","map","animationControls","hasMounted","pendingAnimations","subscribers","Set","controls","subscribe","visualElement","add","delete","definition","transitionOverride","animations","forEach","push","Promise","all","resolve","animation","set","stop","mount","then","useEffect","useAnimation"],"sourceRoot":""}